"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpsValidation = exports.HttpsValidationLevel = void 0;
const inversify_1 = require("inversify");
const dependency_injection_types_1 = require("./dependency.injection.types");
var HttpsValidationLevel;
(function (HttpsValidationLevel) {
    HttpsValidationLevel[HttpsValidationLevel["Unsafe"] = 0] = "Unsafe";
    HttpsValidationLevel[HttpsValidationLevel["Warn"] = 1] = "Warn";
    HttpsValidationLevel[HttpsValidationLevel["Strict"] = 2] = "Strict";
})(HttpsValidationLevel = exports.HttpsValidationLevel || (exports.HttpsValidationLevel = {}));
let HttpsValidation = class HttpsValidation {
    constructor(environment, tlsCertValidator, debug, consoleLogger) {
        this.validated = [];
        this.validationLevel = environment.httpsValidation;
        this._tlsCertValidator = tlsCertValidator;
        this._debug = debug;
        this._console = consoleLogger;
    }
    useRequestHttpsValidation() {
        return this.validationLevel === HttpsValidationLevel.Strict;
    }
    validateRequest(targetHost) {
        if (!this.isSSL(targetHost)) {
            return;
        }
        if (this.validationLevel === HttpsValidationLevel.Strict) {
            return; // the actual request will perform the validation
        }
        this.validatePeerCert(targetHost);
    }
    validateConnect(targetHost) {
        if (!this.isSSL(targetHost)) {
            return;
        }
        this.validatePeerCert(targetHost);
    }
    isSSL(targetHost) {
        return targetHost.protocol === "https:";
    }
    validatePeerCert(targetHost) {
        if (this.validationLevel === HttpsValidationLevel.Unsafe) {
            return; // no validation
        }
        if (this.validationLevel === HttpsValidationLevel.Warn) {
            if (targetHost.hostname === "localhost" ||
                targetHost.hostname === "127.0.0.1" ||
                targetHost.hostname === "[::1]") {
                // Don't validate localhost targets on level Warn
                return;
            }
            // Only validate once per target on level Warn
            if (this.validated.indexOf(targetHost.href) !== -1) {
                return;
            }
            this.validated.push(targetHost.href);
        }
        if (this.isIP(targetHost.hostname)) {
            this._debug.log("Target for HTTPS request is an IP address (" +
                targetHost.hostname +
                "). Will not validate the certificate. Use hostnames for validation support.");
            this._console.warn("cypress-ntlm-auth: Target for HTTPS request is an IP address (" +
                targetHost.hostname +
                "). Will not validate the certificate. Use hostnames for validation support.");
            return;
        }
        this._tlsCertValidator.validate(targetHost).catch((err) => {
            this._console.warn('cypress-ntlm-auth: Certificate validation failed for "' +
                targetHost.host +
                '". ' +
                err.code);
            this._debug.log('WARN: Certificate validation failed for "' + targetHost.host + '".', err);
        });
    }
    reset() {
        this.validated = [];
    }
    isIP(hostname) {
        const ipv4ValidatorRegex = /^(?!0)(?!.*\.$)((1?\d?\d|25[0-5]|2[0-4]\d)(\.|$)){4}$/;
        const ipv6ValidatorRegex = new RegExp(
        // eslint-disable-next-line max-len
        /^\[(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\]$/);
        return (ipv4ValidatorRegex.test(hostname) || ipv6ValidatorRegex.test(hostname));
    }
};
HttpsValidation = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(dependency_injection_types_1.TYPES.IEnvironment)),
    __param(1, (0, inversify_1.inject)(dependency_injection_types_1.TYPES.ITlsCertValidator)),
    __param(2, (0, inversify_1.inject)(dependency_injection_types_1.TYPES.IDebugLogger)),
    __param(3, (0, inversify_1.inject)(dependency_injection_types_1.TYPES.IConsoleLogger)),
    __metadata("design:paramtypes", [Object, Object, Object, Object])
], HttpsValidation);
exports.HttpsValidation = HttpsValidation;
